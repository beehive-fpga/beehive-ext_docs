**Goal:** The app should receive a UDP packet and send a UDP packet back to the client with the data payload unmodified

Beehive works, at a high-level, by incrementally parsing or building packets. Here’s a simple example design for a UDP echo

![[beehive_overview.png]]

Here’s an overview of what’s happening on the receive path

1. A frame comes in from the network completely unprocessed
2. The ethernet RX tile processes it, parsing out the metadata (MAC addresses/type)
3. The ethernet RX tile sends a message to the IP tile with the parsed metadata and the yet unprocessed payload. The header flit is just information for the infrastructure to route to the IP RX tile
4. The IP RX tile processes the unprocessed payload in the message to parse out IP addresses, length, packet type, and check the checksum.
5. The IP RX tile sends a message to the UDP tile with the IP metadata and the remaining unprocessed payload.
6. The UDP RX tile parses out the UDP port, length, and checks the checksum. It determines if there is an application registered for the destination port in the packet
7. The UDP RX tile sends a message to the application tile with the metadata and the application payload

The transmit path runs in the same manner, except it incrementally adds on packet headers into the payload instead of removing

# Building a Simple UDP echo application

### 1. Read the [message format documentation](Message%20Format%20Documentation.md)
- The UDP message format is:
	1. `udp_noc_hdr_flit`
        - For setting the `dst_{x/y}` fields, the coordinates for all the tiles are in `cocotb_test/udp_echo/include/beehive_topology.sv` after the files have been generated. Otherwise, you can get them from the `tile_config.xml` file
        - For setting the `src_{x/y}` fields, these are available from the module parameters
        - The `fbits` fields should be set to `PKT_IF_FBITS`
        - `msg_type` should be either `UDP_TX_SEGMENT`. When you receive a message, the message type will be `UDP_RX_SEGMENT`, but you don’t have to check for this
	2. `udp_{rx/tx}_metadata_flit`, depending on whether you are sending or receiving the UDP packet
        - the `{src/dst}_{ip/port}` fields are set as you would expect
        - `data_length` is the length of the payload of the UDP packet
	3. some number of data flits which is the payload of the UDP packet
### 2. Look at the files in`apps/udp_echo_app/template`
 - `udp_echo_app_template_gen.sv.pyv` is the “toplevel” of the app. It instantiates the control and datapaths, which are in `udp_echo_app_template_ctrl.sv` and `udp_echo_app_template_datap.sv`, respectively
- `*_gen.sv.pyv` files have parts of the Verilog generated by Python. These regions are marked by `<% %>`. You shouldn’t have to modify these
### 3. Write the UDP echo logic across the control and datapath files
### 4. Modify the tile in `apps/udp_echo_app/udp_echo_app_tile_gen.sv.pyv` to instantiate your version of the echo application. 
- The module name is `udp_echo_app_copy_temp`
### 5. Modify the properties under `default` on line 37 in `apps/udp_echo_app/udp_echo_app.core` to the following
```yaml
filesets: [tile, app, template]
generate: [pyhp_generate, template_generate]
```
### 6. Run the testing in `cocotb_test/udp_echo` as described in the README in the root of the repo under “Running a basic test”.